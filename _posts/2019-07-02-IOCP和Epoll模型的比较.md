---
layout:     post                    # 使用的布局（不需要改）
title:      IOCP和EPOLL             # 标题 
subtitle:   比较 #副标题
date:       2019-07-03              # 时间
author:     BY                      # 作者
header-img: img/wkj.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
---

## Hey
##IOCP模型与EPOLL模型的比较

一：IOCP和Epoll之间的异同。

异：

1：IOCP是WINDOWS系统下使用。Epoll是Linux系统下使用。

2：IOCP是IO操作完毕之后，通过Get函数获得一个完成的事件通知。Epoll是当你希望进行一个IO操作时，向Epoll查询是否可读或者可写，若处于可读或可写状态后，Epoll会通过epoll_wait进行通知。

3：IOCP封装了异步的消息事件的通知机制，同时封装了部分IO操作。但Epoll仅仅封装了一个异步事件的通知机制，并不负责IO读写操作。Epoll保持了事件通知和IO操作间的独立性，更加简单灵活。

4： 基于上面的描述，我们可以知道Epoll不负责IO操作，所以它只告诉你当前可读可写了，并且将协议读写缓冲填充，由用户去读写控制，此时我们可以做出额 外的许多操作。IOCP则直接将IO通道里的读写操作都做完了才通知用户，当IO通道里发生了堵塞等状况我们是无法控制的。

同：

1：它们都是异步的事件驱动的网络模型。

2：它们都可以向底层进行指针数据传递，当返回事件时，除可通知事件类型外，还可以通知事件相关数据。

##IOCP是什么呢，全称 IO完成端口。

它是一种WIN32的网络I/O模型，既包括了网络连接部分，也负责了部分的I/O操作功能，用于方便我们控制有并发性的网络I/O操作。它有如下特点：

1：它是一个WIN32内核对象，所以无法运行于Linux.

2：它自己负责维护了工作线程池，同时也负责了I/O通道的内存池。

3：它自己实现了线程的管理以及I/O请求通知，最小化的做到了线程的上下文切换。

4：它自己实现了线程的优化调度，提高了CPU和内存缓冲的使用率。

##使用IOCP的基本步骤很简单：

1：创建IOCP对象，由它负责管理多个Socket和I/O请求。CreateIoCompletionPort需要将IOCP对象和IOCP句柄绑定。

2：创建一个工作线程池，以便Socket发送I/O请求给IOCP对象后，由这些工作线程进行I/O操作。注意，创建这些线程的时候，将这些线程绑定到IOCP上。

3：创建一个监听的socket。

4：轮询，当接收到了新的连接后，将socket和完成端口进行关联并且投递给IOCP一个I/O请求。注意：将Socket和IOCP进行关联的函数和创建IOCP的函数一样，都是CreateIoCompletionPort，不过注意传参必然是不同的。

5：因为是异步的，我们可以去做其他，等待IOCP将I/O操作完成会回馈我们一个消息，我们再进行处理。
其中需要知道的是：I/O请求被放在一个I/O请求队列里面，对，是队列，LIFO机制。当一个设备处理完I/O请求后，将会将这个完成后的I/O请求丢回IOCP的I/O完成队列。
我们应用程序则需要在GetQueuedCompletionStatus去询问IOCP，该I/O请求是否完成。
其中有一些特殊的事情要说明一下，我们有时有需要人工的去投递一些I/O请求，则需要使用PostQueuedCompletionStatus函数向IOCP投递一个I/O请求到它的请求队列中。
